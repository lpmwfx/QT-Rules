{"file": "README.md", "category": "root", "type": "readme", "title": "Qt Rules — AI Anti-Pattern Guides + Config-Driven Architecture", "subtitle": "", "sections": ["MCP Server", "Language Rules (AI Anti-Patterns)", "Architecture Rules (Config-Driven)", "Reading Order", "Relationship to Other Rules", "The Core Problem"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["qml/README.md", "js/README.md", "cpp/README.md", "rust/README.md", "build-rules/README.md", "build-rules/principles.md", "build-rules/layers.md", "build-rules/data-types.md", "build-rules/startup.md", "build-rules/contract.md", "build-rules/qml-rules.md", "build-rules/bridge-ipc.md", "build-rules/validation.md", "build-rules/enforcement.md", "build-rules/threading.md", "build-rules/testing.md", "build-rules/qt-mapping.md", "build-rules/config-paths.md", "build-rules/mvvm-bridge.md", "build-rules/build-system.md", "build-rules/ai-traps.md"], "code_languages": ["bash"], "has_examples": true, "tags": ["anti-pattern", "architecture", "bash", "config-driven", "guides", "q_invokable", "q_object", "q_property", "qobject", "qstandardpaths", "qthread", "qvariantmap", "rules"], "qt_apis": ["QObject", "QStandardPaths", "QThread", "QVariantMap", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": []}
{"file": "build-rules/README.md", "category": "build-rules", "type": "readme", "title": "Build Rules — Config-Driven, Stateless UI/Core with Bridge", "subtitle": "", "sections": ["Files", "Architecture Spec (from original QT-BuildRules)", "Implementation Details (gap-fillers)", "Reading Order"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["principles.md", "layers.md", "data-types.md", "startup.md", "contract.md", "qml-rules.md", "bridge-ipc.md", "validation.md", "enforcement.md", "threading.md", "testing.md", "qt-mapping.md", "config-paths.md", "mvvm-bridge.md", "build-system.md", "ai-traps.md"], "code_languages": [], "has_examples": false, "tags": ["bridge", "build", "config-driven", "core", "interop", "ipc", "q_property", "qobject", "qstandardpaths", "qvariantmap", "rules", "stateless"], "qt_apis": ["QObject", "QStandardPaths", "QVariantMap", "Q_PROPERTY"], "concepts": ["interop", "ipc"]}
{"file": "build-rules/ai-traps.md", "category": "build-rules", "type": "content", "title": "AI Anti-Patterns for Config-Driven Qt Architecture", "subtitle": "The other QT/ files cover language-specific anti-patterns (QML, JS, C++, Rust). This file covers architectural anti-patterns: what AI does wrong when implementing the config-driven, stateless-core, bridge-based architecture from QT-BuildRules.", "sections": ["1. AI Hardcodes Values That Belong in Config", "What AI Does", "Why AI Does This", "The Fix", "2. AI Puts Business Logic in QML", "What AI Does", "The Fix", "3. AI Mutates State Directly Instead of Dispatching", "What AI Does", "Why This Breaks", "The Fix", "4. AI Skips Config Validation", "What AI Does", "The Fix", "5. AI Creates God-Object Store", "What AI Does", "The Fix", "6. AI Mixes Config Layers", "What AI Does", "The Fix", "7. AI Calls OS Directly from Core", "What AI Does", "The Fix", "8. AI Ignores Memory/Session Continuity", "What AI Does", "The Fix", "Summary: AI Default → Config-Driven Correct"], "rules": [], "banned": [], "anti_patterns": ["Rectangle { width: 260; height: 600; color: \"#232629\" }", "if (sources.size() >= 10) return TooManySources;", "server.listen(path, 5);", "function processWorkspace(files) {", "MouseArea {", "auto config = toml::parse_file(\"conf/base/theme.toml\");", "class AppController : public QObject {", "auto config = loadToml(\"~/.config/myapp/theme.toml\");", "void ViewModel::handleAddFolder(const QString &path) {", "int main() {"], "correct_patterns": ["Button {", "MouseArea {", "auto config = toml::parse_file(\"conf/base/theme.toml\");", "class Store : public QObject {", "auto base = loadToml(basePath + \"/theme.toml\");", "std::pair<State, std::vector<Effect>> ViewModel::handle(", "int main() {"], "refs": [], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["anti-patterns", "architecture", "common-mistakes", "config-driven", "configuration", "cpp", "q_invokable", "q_object", "q_property", "qdir", "qguiapplication", "qml", "qobject", "qstring", "qvariantlist", "qvariantmap", "schema", "separation", "settings", "type-checking"], "qt_apis": ["QDir", "QGuiApplication", "QObject", "QString", "QVariantList", "QVariantMap", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": ["anti-patterns", "architecture", "common-mistakes", "configuration", "schema", "separation", "settings", "type-checking"]}
{"file": "build-rules/bridge-ipc.md", "category": "build-rules", "type": "content", "title": "Bridge & IPC Rules", "subtitle": "Adapter pattern. Transport-agnostic. Qt-specific options where needed.", "sections": ["Adapter Pattern", "IPC Options (Guideline)", "Bootstrap Minimum"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["contract.md", "mvvm-bridge.md", "config-paths.md"], "code_languages": [], "has_examples": false, "tags": ["bridge", "interop", "ipc", "qlocalserver", "qlocalsocket", "rules"], "qt_apis": ["QLocalServer", "QLocalSocket"], "concepts": ["interop", "ipc"]}
{"file": "build-rules/build-system.md", "category": "build-rules", "type": "content", "title": "Build System — CMake and Cargo for Qt Projects", "subtitle": "QT-BuildRules defines architecture but not how to build it. This file covers CMake (C++ Qt) and Cargo + CMake (Rust Qt via cxx-qt).", "sections": ["Principle", "1. CMake — C++ Qt Project", "Top-Level CMakeLists.txt", "core/CMakeLists.txt — No Qt Dependency", "adapters/CMakeLists.txt — Qt Allowed Here", "app/CMakeLists.txt — Wiring Only", "QML Resources (qml.qrc)", "2. Cargo + CMake — Rust Qt via cxx-qt", "Workspace Structure", "Cargo.toml (Workspace)", "core/Cargo.toml — No Qt", "qt-bridge/Cargo.toml — cxx-qt", "qt-bridge/build.rs", "CMakeLists.txt (Top-Level) — Corrosion", "app/CMakeLists.txt", "3. Build Targets and Isolation Check", "Architecture Enforcement via Build", "CI Verification", "4. Debug and Release Profiles", "CMake", "Cargo", "5. Config Installation"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": ["bash", "cmake", "rust", "toml", "xml"], "has_examples": true, "tags": ["bash", "bridge", "build", "build-system", "cargo", "cmake", "configuration", "ffi", "linting", "projects", "qstandardpaths", "quality", "rust", "settings", "system", "toml", "xml"], "qt_apis": ["QStandardPaths"], "concepts": ["bridge", "build-system", "cmake", "configuration", "ffi", "linting", "quality", "settings"]}
{"file": "build-rules/config-paths.md", "category": "build-rules", "type": "content", "title": "Config Paths — Qt Standard Locations", "subtitle": "QT-BuildRules §3.1 defines config layering (base/override/runtime) but doesn't map to actual filesystem paths on Linux/Flatpak. This file fills that gap.", "sections": ["Principle", "Path Resolution", "XDG Base Directories (Linux/BSD)", "Mapping to BuildRules Config Layers", "Resolution Order", "Flatpak Sandbox", "Socket Paths", "Memory Persistence Path", "Environment Variable Overrides", "Checklist"], "rules": ["Use `QStandardPaths` exclusively — never construct paths manually", "`QStandardPaths` handles Flatpak remapping automatically", "Never use `QDir::homePath()` + hardcoded relative path", "Socket dir must be created at startup if it doesn't exist", "Clean up socket file on shutdown (or check for stale socket on startup)", "Socket path must come from config — not hardcoded", "Env var overrides are for dev/test only", "Production uses QStandardPaths exclusively", "Document env vars in bootstrap.json or README"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": ["cpp"], "has_examples": true, "tags": ["architecture", "config", "configuration", "cpp", "file-paths", "locations", "paths", "qdir", "qiodevice", "qjsondocument", "qsavefile", "qstandardpaths", "qstring", "qstringlist", "qvariantmap", "separation", "settings", "standard"], "qt_apis": ["QDir", "QIODevice", "QJsonDocument", "QSaveFile", "QStandardPaths", "QString", "QStringList", "QVariantMap"], "concepts": ["architecture", "configuration", "file-paths", "separation", "settings"]}
{"file": "build-rules/contract.md", "category": "build-rules", "type": "content", "title": "The Contract — Events, Patches, and Effects", "subtitle": "How layers communicate. Transport-agnostic protocol.", "sections": ["Event Rules", "Patch Rules", "Effects"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["mvvm-bridge.md", "qt-mapping.md", "threading.md"], "code_languages": [], "has_examples": false, "tags": ["contract", "effects", "events", "interface", "patches", "protocol"], "qt_apis": [], "concepts": ["interface", "protocol"]}
{"file": "build-rules/data-types.md", "category": "build-rules", "type": "content", "title": "Data Types — Config, Memory, Runtime State", "subtitle": "Three distinct data categories. Each has different lifecycle, storage, and rules.", "sections": ["Config (Rules & Tokens)", "Memory (Resume/Continuity)", "Runtime State"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["config-paths.md", "qt-mapping.md"], "code_languages": [], "has_examples": false, "tags": ["config", "configuration", "data", "memory", "qstandardpaths", "runtime", "settings", "state", "state-management", "type-conversion", "type-safety", "types"], "qt_apis": ["QStandardPaths"], "concepts": ["configuration", "settings", "state-management", "type-conversion", "type-safety"]}
{"file": "build-rules/enforcement.md", "category": "build-rules", "type": "content", "title": "Enforcement, Repo Structure, and Definition of Done", "subtitle": "How we prevent \"cheating\". Where files go. When a feature is compliant.", "sections": ["No-Literals Policy", "Coverage Checks", "Logging/Diagnostics", "Repository Structure (Recommended)", "Definition of Done (Architecture Compliance)"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["ai-traps.md"], "code_languages": [], "has_examples": false, "tags": ["definition", "done", "enforcement", "linting", "quality", "repo", "structure"], "qt_apis": [], "concepts": ["linting", "quality"]}
{"file": "build-rules/layers.md", "category": "build-rules", "type": "content", "title": "Layer Architecture", "subtitle": "Four layers. Each has one role. Dependencies point inward.", "sections": ["Overview", "UI Layer (Qt/QML)", "Immutable Core", "Mutable PAL (Platform Abstraction Layer)", "Bridge (UI ↔ Backend Adapter)"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": [], "has_examples": false, "tags": ["architecture", "interop", "ipc", "layer", "qlocalsocket", "separation"], "qt_apis": ["QLocalSocket"], "concepts": ["architecture", "interop", "ipc", "separation"]}
{"file": "build-rules/licensing.md", "category": "build-rules", "type": "content", "title": "Qt Licensing — LGPL Compliance for Commercial Products", "subtitle": "We use Qt Open Source (LGPL 3.0) by default. Commercial products MUST follow LGPL rules to avoid license violation.", "sections": ["The License Landscape", "LGPL Compliance Checklist", "1. Dynamic Linking (Non-Negotiable)", "2. Attribution and Notice", "3. Re-Linking Capability", "4. Modification Disclosure", "Qt Module License Map", "LGPL 3.0 (Safe for Commercial)", "GPL Only (Requires Commercial License for Proprietary Use)", "KDE Frameworks (LGPL 2.1+)", "Architecture = License Protection", "Build System Verification", "CMake Check", "CI Check", "Flatpak / AppImage Distribution", "Summary"], "rules": ["Default to Qt Open Source (LGPL 3.0) — no commercial license required if LGPL is followed", "Always link Qt dynamically — static linking triggers LGPL copyleft on your code", "Never modify Qt source without releasing those modifications under LGPL", "Ship a prominent LGPL notice in your application (About dialog, README, or LICENSE file)", "Users must be able to re-link your application against a different Qt version", "Check every Qt module's license before using it — some are GPL-only", "Keep your proprietary code in core/ (no Qt dependency) — this is never at risk", "CMake `find_package(Qt6)` defaults to shared libs — do not override this", "Before adding a Qt module to CMakeLists.txt, verify its license at https://doc.qt.io/qt-6/licenses-used-in-qt.html", "core/ must never depend on Qt — this keeps your business logic outside LGPL scope", "adapters/ links Qt dynamically — LGPL compliance is automatic with shared libs", "Flatpak with org.kde.Platform or org.kde.Sdk runtime handles Qt LGPL automatically", "AppImage must include Qt .so files as replaceable shared libs + LGPL notice"], "banned": ["Static linking of Qt libraries in commercial/proprietary products", "Using GPL-only Qt modules in proprietary products without commercial license", "Tivoization — hardware that prevents users from replacing Qt libraries", "Hiding Qt usage — LGPL requires attribution and notice"], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": ["bash", "cmake"], "has_examples": true, "tags": ["bash", "cmake", "commercial", "compliance", "lgpl", "license", "licensing", "products"], "qt_apis": [], "concepts": ["compliance", "lgpl", "license"]}
{"file": "build-rules/mvvm-bridge.md", "category": "build-rules", "type": "content", "title": "MVVM ↔ BuildRules Alignment", "subtitle": "QT-BuildRules §2.2 describes a reducer pattern. The existing KDE_QT/mvvm.md describes MVVM with AppCommand/ViewEvent. This file reconciles the two.", "sections": ["The Conflict", "The Mapping", "Unified Model", "What BuildRules Adds to MVVM", "What MVVM Adds to BuildRules", "Terminology Convention", "The Audit (Combined)"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": [], "has_examples": false, "tags": ["alignment", "architecture", "buildrules", "data-model", "mvc", "mvvm", "pattern", "qfile", "qlocalsocket", "qobject", "qprocess", "qvariantmap"], "qt_apis": ["QFile", "QLocalSocket", "QObject", "QProcess", "QVariantMap"], "concepts": ["architecture", "data-model", "mvc", "pattern"]}
{"file": "build-rules/principles.md", "category": "build-rules", "type": "content", "title": "Core Principles", "subtitle": "The non-negotiable rules that govern the entire architecture.", "sections": ["1. No Hidden Values", "2. Stateless Code, State in Data", "3. Determinism", "4. Replaceability", "Non-Goals"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": [], "has_examples": false, "tags": ["architecture", "core", "design", "principles"], "qt_apis": [], "concepts": ["architecture", "design"]}
{"file": "build-rules/qml-rules.md", "category": "build-rules", "type": "content", "title": "QML-Specific Rules", "subtitle": "Tokens only. Design-system wrappers. Read-only state.", "sections": ["Tokens Only", "Design-System Components", "Read-Only State"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["qt-mapping.md"], "code_languages": [], "has_examples": false, "tags": ["declarative", "q_property", "qml-specific", "qobject", "rules", "ui-patterns"], "qt_apis": ["QObject", "Q_PROPERTY"], "concepts": ["declarative", "ui-patterns"]}
{"file": "build-rules/qt-mapping.md", "category": "build-rules", "type": "content", "title": "Qt API Mapping — Store, Dispatch, Patches in Concrete Qt", "subtitle": "QT-BuildRules §6.3 says `Store.dispatch(event)` and `Store.state` but doesn't show how these map to actual Qt/QML mechanisms. This file fills that gap.", "sections": ["The Problem", "Store = C++ QObject Singleton Exposed to QML", "Registration", "dispatch() = Serialize Event and Send to Bridge", "Patches = Targeted State Updates", "Patch Format (QVariantMap)", "applyPatch Implementation", "Tokens = Config Loaded at Startup, Exposed as QVariantMap", "Design-System Components (AxButton etc.) = QML Wrappers", "Constraints in QML", "Summary: Abstract → Qt Concrete"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["api", "api-mapping", "boot", "concrete", "configuration", "cpp", "dispatch", "implementation", "initialization", "interop", "ipc", "mapping", "patches", "q_invokable", "q_object", "q_property", "qml", "qobject", "qstring", "qstringlist", "qvariant", "qvariantlist", "qvariantmap", "settings", "store"], "qt_apis": ["QObject", "QString", "QStringList", "QVariant", "QVariantList", "QVariantMap", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": ["api-mapping", "boot", "configuration", "implementation", "initialization", "interop", "ipc", "settings"]}
{"file": "build-rules/startup.md", "category": "build-rules", "type": "content", "title": "Startup / Reload Model", "subtitle": "How the app boots, how config reloads, and when state is persisted.", "sections": ["Boot Sequence", "Config Reload Policy", "Persistence Cadence"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["config-paths.md"], "code_languages": [], "has_examples": false, "tags": ["boot", "configuration", "data-model", "initialization", "model", "mvc", "qsavefile", "reload", "settings", "startup"], "qt_apis": ["QSaveFile"], "concepts": ["boot", "configuration", "data-model", "initialization", "mvc", "settings"]}
{"file": "build-rules/testing.md", "category": "build-rules", "type": "content", "title": "Testing Strategy — Per Layer", "subtitle": "QT-BuildRules defines four layers (UI, Core, PAL, Bridge) but no test strategy. This file defines what to test, how, and with what tools for each layer.", "sections": ["Principle", "1. Core Tests (Unit — No I/O, No Qt)", "What to test", "How", "Rules", "2. PAL Tests (Integration — Real OS)", "What to test", "How", "Rules", "3. Bridge Tests (Contract — Serialization Fixtures)", "What to test", "How", "Rules", "4. UI Tests (QML — Binding and Visual)", "What to test", "How", "MockStore", "Rules", "5. End-to-End Tests (Full Stack)", "What to test", "How", "Rules", "Test Pyramid", "CI Pipeline Order"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": [], "code_languages": ["cpp", "qml", "rust"], "has_examples": true, "tags": ["cpp", "declarative", "interface", "interop", "ipc", "layer", "per", "protocol", "qfile", "qiodevice", "qml", "qtemporarydir", "qtest", "quality", "reactive", "rust", "strategy", "test", "testing"], "qt_apis": ["QFile", "QIODevice", "QTemporaryDir", "QTest"], "concepts": ["declarative", "interface", "interop", "ipc", "protocol", "quality", "reactive", "test"]}
{"file": "build-rules/threading.md", "category": "build-rules", "type": "content", "title": "Threading Model — Who Runs Where", "subtitle": "QT-BuildRules §2 defines layers (UI, Core, PAL, Bridge) but does not specify which thread each layer runs on. This file fills that gap.", "sections": ["The Rule", "Thread Map", "Cross-Thread Communication", "GUI ↔ Core: Queued signals or channels", "Core ↔ PAL: Effects as commands, results as events", "Qt Event Loop Ownership", "Polling patches on GUI thread", "What AI Gets Wrong", "Thread Safety Checklist"], "rules": ["`QCoreApplication::exec()` owns the main event loop — it runs on the GUI thread", "`QThread` provides a secondary event loop for worker objects", "Never run a second event loop (no nested `exec()`, no tokio runtime)", "Use `QTimer::singleShot(0, ...)` to defer work to next event loop iteration on GUI thread"], "banned": [], "anti_patterns": ["Blocking I/O on GUI thread", "std::thread for Qt work", "Shared mutex between GUI and Core", "Direct Store.state mutation from worker", "QThread::run() subclass", "tokio/async-std runtime"], "correct_patterns": [], "refs": [], "code_languages": ["cpp", "rust"], "has_examples": true, "tags": ["concurrency", "cpp", "data-model", "event-handling", "lifetime", "memory-management", "model", "mvc", "qcoreapplication", "qfile", "qlocalsocket", "qprocess", "qquickitem", "qthread", "qtimer", "qwidget", "runs", "rust", "signals-slots", "threading", "threads", "where"], "qt_apis": ["QCoreApplication", "QFile", "QLocalSocket", "QProcess", "QQuickItem", "QThread", "QTimer", "QWidget"], "concepts": ["concurrency", "data-model", "event-handling", "lifetime", "memory-management", "mvc", "signals-slots", "threads"]}
{"file": "build-rules/validation.md", "category": "build-rules", "type": "content", "title": "Validation, Safe-Mode, and Migration", "subtitle": "Schema validation on every load. Versioned migration. Never silently ignore.", "sections": ["Schema Validation", "Versioning & Migration", "Safe-Mode"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["startup.md", "data-types.md"], "code_languages": [], "has_examples": false, "tags": ["migration", "safe-mode", "schema", "type-checking", "validation"], "qt_apis": [], "concepts": ["schema", "type-checking"]}
{"file": "cpp/README.md", "category": "cpp", "type": "readme", "title": "C++ in Qt — Rules and AI Anti-Patterns", "subtitle": "Qt has its own ownership model, threading model, and type system. AI trained on modern C++ (non-Qt) will fight these and produce broken code.", "sections": ["The Problem", "File Index"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["ownership.md", "q-object.md", "threading.md", "q-property.md", "q-invokable.md", "connections.md", "types.md", "model-view.md", "engine-ownership.md", "quick-ref.md"], "code_languages": [], "has_examples": false, "tags": ["anti-patterns", "q_invokable", "q_object", "q_property", "qabstractlistmodel", "qobject", "qthread", "rules"], "qt_apis": ["QAbstractListModel", "QObject", "QThread", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": []}
{"file": "cpp/connections.md", "category": "cpp", "type": "content", "title": "Signal/Slot Connection Types", "subtitle": "Use function pointer syntax for compile-time checked connections.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["`connect()` with function pointers — not string-based `SIGNAL()`/`SLOT()`", "Cross-thread connections are `Qt::QueuedConnection` by default (auto-detected)", "Use `Qt::QueuedConnection` explicitly if in doubt about threads", "Use `QObject::disconnect()` or connection handle to avoid dangling connections"], "banned": ["`SIGNAL()`/`SLOT()` string-based connections", "`Qt::DirectConnection` across threads", "Lambda without context object (dangling if target destroyed)"], "anti_patterns": ["connect(button, SIGNAL(clicked()), this, SLOT(handleClick()));  // typo = silent fail"], "correct_patterns": ["connect(button, &QPushButton::clicked, this, &App::handleClick);"], "refs": ["threading.md", "q-object.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["connection", "cpp", "event-handling", "q_object", "qobject", "qpushbutton", "signal", "signals-slots", "slot", "type-conversion", "type-safety", "types"], "qt_apis": ["QObject", "QPushButton", "Q_OBJECT"], "concepts": ["event-handling", "signals-slots", "type-conversion", "type-safety"]}
{"file": "cpp/engine-ownership.md", "category": "cpp", "type": "content", "title": "QML Engine Ownership Rules", "subtitle": "Objects returned from Q_INVOKABLE are owned by the QML engine and may be garbage collected.", "sections": ["Danger Zone", "Safe Pattern"], "rules": ["Objects returned from Q_INVOKABLE are owned by QML engine (GC'd)", "Objects set as context properties are NOT owned by QML", "Use `QQmlEngine::setObjectOwnership()` to control explicitly", "If QML deletes a C++ object you still hold a pointer to — crash"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["ownership.md", "q-invokable.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["cpp", "engine", "js-engine", "lifetime", "memory-management", "ownership", "q_invokable", "qml", "qml-engine", "qobject", "qqmlengine", "rules", "v4"], "qt_apis": ["QObject", "QQmlEngine", "Q_INVOKABLE"], "concepts": ["js-engine", "lifetime", "memory-management", "qml-engine", "v4"]}
{"file": "cpp/model-view.md", "category": "cpp", "type": "content", "title": "Model/View — Use It, Don't Reinvent It", "subtitle": "Use QAbstractListModel for QML ListView data with proper change notifications.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use `QAbstractListModel` for QML ListView data", "Implement `roleNames()`, `rowCount()`, `data()` minimum", "Emit `beginInsertRows`/`endInsertRows` for proper QML update", "Never populate a QML ListModel from C++ in a loop"], "banned": [], "anti_patterns": ["Q_INVOKABLE QVariantList getFiles() {"], "correct_patterns": ["class FileModel : public QAbstractListModel {"], "refs": ["q-object.md", "types.md", "q-property.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["cpp", "data-model", "don", "model", "mvc", "q_invokable", "q_object", "qabstractlistmodel", "qbytearray", "qhash", "qmodelindex", "qvariant", "qvariantlist", "qvector", "reinvent", "use", "view"], "qt_apis": ["QAbstractListModel", "QByteArray", "QHash", "QModelIndex", "QVariant", "QVariantList", "QVector", "Q_INVOKABLE", "Q_OBJECT"], "concepts": ["data-model", "mvc"]}
{"file": "cpp/ownership.md", "category": "cpp", "type": "content", "title": "Ownership: Qt Parent-Child, Not Smart Pointers", "subtitle": "QObject-derived classes use parent-child lifetime — parent deletes children automatically.", "sections": ["What AI Does (Wrong)", "What to Write Instead", "When Smart Pointers ARE Correct"], "rules": ["QObject-derived classes use parent-child ownership — parent deletes children", "Use `new` with parent pointer — Qt manages lifetime", "`std::unique_ptr` only for non-QObject types or explicit detach scenarios", "Never `delete` a QObject that has a parent", "Never `std::unique_ptr<QObject>` with a parent set — double delete"], "banned": [], "anti_patterns": ["auto label = std::make_unique<QLabel>(\"Hello\");", "auto *button = new QPushButton(\"OK\", parentWidget);"], "correct_patterns": ["auto *label = new QLabel(\"Hello\", this);     // 'this' is parent"], "refs": ["engine-ownership.md", "quick-ref.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["cpp", "lifetime", "memory-management", "ownership", "parent-child", "pointers", "qlabel", "qobject", "qpushbutton", "qvboxlayout", "smart"], "qt_apis": ["QLabel", "QObject", "QPushButton", "QVBoxLayout"], "concepts": ["lifetime", "memory-management"]}
{"file": "cpp/q-invokable.md", "category": "cpp", "type": "content", "title": "Q_INVOKABLE — The QML Call Interface", "subtitle": "Methods callable from QML MUST be Q_INVOKABLE or public slots.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Methods callable from QML MUST be `Q_INVOKABLE` or `public slots`", "Q_INVOKABLE for command-style methods (user actions)", "Return types must be QML-compatible (QString, QVariant, QVariantList, QVariantMap)", "Use QVariantMap for structured data — not custom types without Q_GADGET"], "banned": [], "anti_patterns": ["class Controller : public QObject {", "Q_INVOKABLE std::vector<FileEntry> getFiles();  // QML can't use std::vector"], "correct_patterns": ["class Controller : public QObject {"], "refs": ["q-object.md", "q-property.md", "types.md", "engine-ownership.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["api-exposure", "call", "cpp", "interface", "invokable", "q_gadget", "q_invokable", "q_object", "qml", "qml-integration", "qobject", "qstring", "qvariant", "qvariantlist", "qvariantmap"], "qt_apis": ["QObject", "QString", "QVariant", "QVariantList", "QVariantMap", "Q_GADGET", "Q_INVOKABLE", "Q_OBJECT"], "concepts": ["api-exposure", "qml-integration"]}
{"file": "cpp/q-object.md", "category": "cpp", "type": "content", "title": "Q_OBJECT Macro — Always Required for Signals/Slots", "subtitle": "Missing Q_OBJECT causes silent failures — moc skips the class entirely.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Every QObject subclass with signals, slots, or Q_PROPERTY MUST have Q_OBJECT", "Missing Q_OBJECT causes silent failures — moc skips the class", "Q_OBJECT must be the FIRST thing in the class (private section)"], "banned": [], "anti_patterns": ["class FileWatcher : public QObject {"], "correct_patterns": ["class FileWatcher : public QObject {"], "refs": ["connections.md", "q-property.md", "q-invokable.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["always", "cpp", "event-handling", "macro", "meta-object", "moc", "object", "q_invokable", "q_object", "q_property", "qobject", "qstring", "required", "signals", "signals-slots", "slots"], "qt_apis": ["QObject", "QString", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": ["event-handling", "meta-object", "moc", "signals-slots"]}
{"file": "cpp/q-property.md", "category": "cpp", "type": "content", "title": "Q_PROPERTY — Required for QML Exposure", "subtitle": "Every value visible in QML MUST be a Q_PROPERTY with a NOTIFY signal.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Every value visible in QML MUST be a Q_PROPERTY", "Q_PROPERTY must have NOTIFY signal for QML bindings to work", "Missing NOTIFY = QML reads the value once, never updates"], "banned": [], "anti_patterns": ["class Backend : public QObject {"], "correct_patterns": ["class Backend : public QObject {", "Text { text: backend.userName }"], "refs": ["q-object.md", "q-invokable.md", "types.md"], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["cpp", "data-binding", "exposure", "property", "q-property", "q_invokable", "q_object", "q_property", "qml", "qobject", "qstring", "required"], "qt_apis": ["QObject", "QString", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": ["data-binding", "q-property"]}
{"file": "cpp/quick-ref.md", "category": "cpp", "type": "quick-ref", "title": "Common AI Mistakes — Quick Reference", "subtitle": "One-table summary of what AI gets wrong in Qt C++ and the correct patterns.", "sections": ["Detailed Rules by Topic"], "rules": [], "banned": [], "anti_patterns": ["std::make_unique<QWidget>()", "Missing Q_OBJECT", "std::thread for Qt work", "Missing NOTIFY on Q_PROPERTY", "SIGNAL()/SLOT() strings", "Public method without Q_INVOKABLE", "Returns std::vector to QML", "Qt types in core logic", "QVariantList instead of model", "delete a parented QObject", "QThread::run() subclass", "Lambda connect without context", "QObject::findChild<>()", "Qt::DirectConnection cross-thread"], "correct_patterns": ["new QWidget(parent)", "Always add Q_OBJECT", "QThread + worker object", "Always add NOTIFY signal", "Function pointer connect", "Add Q_INVOKABLE", "Return QVariantList", "std types in core, convert at adapter", "QAbstractListModel", "Let parent manage lifetime", "Worker-object + moveToThread", "Always pass context (3rd arg)", "Store references, use proper API", "Qt::AutoConnection (default)"], "refs": ["ownership.md", "q-object.md", "threading.md", "q-property.md", "q-invokable.md", "connections.md", "types.md", "model-view.md", "engine-ownership.md"], "code_languages": [], "has_examples": false, "tags": ["common", "mistakes", "q_invokable", "q_object", "q_property", "qabstractlistmodel", "qobject", "qthread", "quick", "qvariantlist", "qwidget", "reference"], "qt_apis": ["QAbstractListModel", "QObject", "QThread", "QVariantList", "QWidget", "Q_INVOKABLE", "Q_OBJECT", "Q_PROPERTY"], "concepts": []}
{"file": "cpp/threading.md", "category": "cpp", "type": "content", "title": "Threading: QThread, Not std::thread", "subtitle": "Qt has its own threading model with event loops — std::thread bypasses all of it.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use `QThread` for threads that interact with Qt objects", "Use `QtConcurrent::run` for fire-and-forget computation", "Use worker-object pattern: create QObject, moveToThread, connect signals", "Never access QWidget/QML from non-GUI thread", "Queued connections for cross-thread signal/slot"], "banned": ["`std::thread` for anything touching QObject", "Subclassing `QThread::run()` (use worker-object pattern)", "`QThread::terminate()` (causes undefined state)", "Accessing GUI from worker thread"], "anti_patterns": ["std::thread t([this]() {", "class Worker : public QThread {"], "correct_patterns": ["class Worker : public QObject {", "QFuture<Result> future = QtConcurrent::run([data]() {"], "refs": ["connections.md", "ownership.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["concurrency", "cpp", "q_object", "qfuture", "qfuturewatcher", "qobject", "qthread", "qvariantmap", "qwidget", "std", "thread", "threading", "threads"], "qt_apis": ["QFuture", "QFutureWatcher", "QObject", "QThread", "QVariantMap", "QWidget", "Q_OBJECT"], "concepts": ["concurrency", "threads"]}
{"file": "cpp/types.md", "category": "cpp", "type": "content", "title": "Qt Types vs Standard C++ Types", "subtitle": "Use Qt types at API boundaries, standard C++ in core logic, convert at the adapter layer.", "sections": ["Boundary Rules", "What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use Qt types in Qt API boundaries (signals, properties, QML interface)", "Use standard C++ types in core/business logic (hexagon core)", "Convert at the adapter boundary — never leak Qt types into core"], "banned": [], "anti_patterns": ["struct FileEntry {"], "correct_patterns": ["struct FileEntry {"], "refs": ["q-property.md", "q-invokable.md", "model-view.md"], "code_languages": ["cpp"], "has_examples": true, "tags": ["cpp", "q_property", "qstring", "qstringlist", "qvariantmap", "standard", "type-conversion", "type-safety", "types"], "qt_apis": ["QString", "QStringList", "QVariantMap", "Q_PROPERTY"], "concepts": ["type-conversion", "type-safety"]}
{"file": "js/README.md", "category": "js", "type": "readme", "title": "JavaScript in Qt/QML Apps — Rules and AI Anti-Patterns", "subtitle": "Qt's JS engine (V4) is NOT a browser, NOT Node.js, NOT V8. AI models trained on web JS will produce code that silently breaks in QML.", "sections": ["File Index", "Summary"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["engine.md", "glue-code.md", "standalone.md", "pragma-library.md", "network.md", "types.md", "quick-ref.md", "performance.md", "validation.md"], "code_languages": [], "has_examples": false, "tags": ["anti-patterns", "apps", "javascript", "q_invokable", "q_property", "qml", "rules"], "qt_apis": ["Q_INVOKABLE", "Q_PROPERTY"], "concepts": []}
{"file": "js/engine.md", "category": "js", "type": "content", "title": "QML JS Is NOT Web JS", "subtitle": "Qt's V4 engine supports a LIMITED subset of ECMAScript. What works in Chrome/Node often fails silently or causes runtime errors in QML.", "sections": ["What V4 Supports (Qt 6)", "What V4 Does NOT Support", "What AI Will Generate (Wrong)", "What to Write Instead"], "rules": [], "banned": ["`import`/`export` (ESM modules) — QML has its own module system", "`require()` — no CommonJS", "`async`/`await` — not available in V4", "`Promise` — not native in V4 (use Qt.callLater or C++ async)", "`fetch()` — no browser API (use XMLHttpRequest or C++ network)", "`setTimeout`/`setInterval` — use QML `Timer {}` component", "`console.error`/`console.warn` — use `console.log` only (or C++ logging)", "Optional chaining `?.` — not available in V4", "Nullish coalescing `??` — not available in V4", "Spread operator on objects `{...obj}` — limited support", "`Map`, `Set`, `WeakMap`, `WeakRef` — not available in V4", "`Symbol` — not available", "Classes with `class` keyword — use Qt.createComponent or plain objects", "`Array.from()`, `.includes()`, `.find()`, `.flat()` — limited availability", "`Object.entries()`, `Object.values()`, `Object.fromEntries()` — not available"], "anti_patterns": ["const result = await fetchData(url);"], "correct_patterns": ["Timer {"], "refs": ["quick-ref.md", "pragma-library.md", "network.md"], "code_languages": ["javascript", "qml"], "has_examples": true, "tags": ["javascript", "js-engine", "qml", "v4", "web"], "qt_apis": [], "concepts": ["js-engine", "v4"]}
{"file": "js/glue-code.md", "category": "js", "type": "content", "title": "JS in QML Is Glue Code — Not Business Logic", "subtitle": "JS in QML files is ONLY for UI wiring. Business logic belongs in C++ or Rust.", "sections": ["Why", "What AI Does (Wrong)", "What to Write Instead"], "rules": ["JS in QML files is ONLY for UI glue (signal wiring, simple transforms)", "Business logic belongs in C++ or Rust, exposed via Q_INVOKABLE or signals", "Max 5-10 lines of JS in any signal handler", "If a JS function exceeds 15 lines, it belongs in C++/Rust"], "banned": [], "anti_patterns": ["function processFiles(fileList) {"], "correct_patterns": ["Q_INVOKABLE QVariantList processFiles(const QStringList &fileList);", "ListView {"], "refs": ["performance.md", "validation.md", "types.md"], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["adapter", "business", "code", "cpp", "glue", "integration", "logic", "q_invokable", "qml", "qstringlist", "qvariantlist"], "qt_apis": ["QStringList", "QVariantList", "Q_INVOKABLE"], "concepts": ["adapter", "integration"]}
{"file": "js/network.md", "category": "js", "type": "content", "title": "XMLHttpRequest — The Only Network API", "subtitle": "QML JS has no fetch(), no axios, no npm HTTP libraries. XMLHttpRequest is the only option.", "sections": ["Correct Pattern", "Better: Move to C++"], "rules": ["Use `XMLHttpRequest` for HTTP in QML JS (it is the only option)", "For complex networking, use C++ `QNetworkAccessManager` exposed to QML", "Never use fetch(), axios, or any npm-based HTTP library in QML"], "banned": [], "anti_patterns": [], "correct_patterns": ["function loadData(url, callback) {"], "refs": ["engine.md", "glue-code.md", "validation.md"], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["api", "cpp", "http", "network", "only", "q_invokable", "q_object", "qml", "qnetworkaccessmanager", "qobject", "qstring", "qvariantmap", "xmlhttprequest"], "qt_apis": ["QNetworkAccessManager", "QObject", "QString", "QVariantMap", "Q_INVOKABLE", "Q_OBJECT"], "concepts": ["api", "http"]}
{"file": "js/performance.md", "category": "js", "type": "content", "title": "Performance Rules", "subtitle": "If it runs per-frame or per-delegate: it must be C++.", "sections": ["Why JS in QML Is Slow", "The Rule of Thumb"], "rules": ["Avoid creating JS objects in hot paths (bindings, delegates)", "Use C++ models (QAbstractListModel) — not JS arrays — for ListView", "Never use JS `for` loops to populate ListModel — populate from C++", "Avoid string concatenation in bindings — use Qt.formatString or C++", "Keep signal handlers under 5 lines — defer to C++ for heavy work"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["glue-code.md", "types.md", "engine.md"], "code_languages": [], "has_examples": false, "tags": ["optimization", "performance", "qabstractlistmodel", "rules"], "qt_apis": ["QAbstractListModel"], "concepts": ["optimization"]}
{"file": "js/pragma-library.md", "category": "js", "type": "content", "title": ".pragma library — QML's JS Module System", "subtitle": "QML has its own module pattern for shared JS. It is NOT ESM.", "sections": ["Correct Pattern", "What AI Does (Wrong)"], "rules": ["Use `.pragma library` for shared utility functions", "Library JS files have NO access to QML component scope (no `parent`, no `root`)", "Library JS files are singletons — state persists across all importers"], "banned": [], "anti_patterns": ["export function formatBytes(bytes) { ... }"], "correct_patterns": [".pragma library", "import \"utils.js\" as Utils"], "refs": ["engine.md", "standalone.md", "glue-code.md"], "code_languages": ["javascript", "qml"], "has_examples": true, "tags": ["code-organization", "javascript", "library", "module", "modules", "pragma", "qml", "system"], "qt_apis": [], "concepts": ["code-organization", "modules"]}
{"file": "js/quick-ref.md", "category": "js", "type": "quick-ref", "title": "Common AI Mistakes — Quick Reference", "subtitle": "A lookup table of what AI generates (wrong) and the correct Qt/QML pattern.", "sections": [], "rules": [], "banned": [], "anti_patterns": ["async/await", "fetch()", "setTimeout()", "import {...} from", "?. optional chain", "?? nullish", "class Foo {}", "Array.includes()", "Object.keys().map()", "template ${tag}", "let/const in loop", "...spread on object", "npm packages in QML", "DOM manipulation"], "correct_patterns": ["Callback or C++ signal", "XMLHttpRequest or C++ QNetworkAccessManager", "Timer { } component", ".pragma library + QML import", "(x && x.y) ? x.y : default", "(x !== null && x !== undefined) ? x : default", "Plain object or C++ QObject", "indexOf(x) !== -1", "for (var key in obj) loop", "Works in Qt 6, check version", "Use var in for loops if scoping issues", "Manual property copy", "Write in C++ or .pragma library", "QML property bindings"], "refs": ["engine.md", "pragma-library.md", "network.md"], "code_languages": [], "has_examples": false, "tags": ["common", "mistakes", "qnetworkaccessmanager", "qobject", "quick", "reference"], "qt_apis": ["QNetworkAccessManager", "QObject"], "concepts": []}
{"file": "js/standalone.md", "category": "js", "type": "content", "title": "Vanilla JS Files in Qt Projects (Non-QML)", "subtitle": "Qt projects sometimes include standalone JS files that run under Node.js, not the V4 engine.", "sections": ["How to Tell"], "rules": ["Standalone JS files (NOT loaded by QML) follow ~/.rules/JS/RULES", "QML-loaded JS files follow the rules in this directory", "Never mix the two — a .js file is either QML-loaded or standalone, never both"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["pragma-library.md", "engine.md"], "code_languages": [], "has_examples": false, "tags": ["files", "isolation", "modules", "non-qml", "projects", "vanilla"], "qt_apis": [], "concepts": ["isolation", "modules"]}
{"file": "js/types.md", "category": "js", "type": "content", "title": "Type Discipline in QML JS", "subtitle": "Property types are the ONLY type-safety QML gives you — use them.", "sections": ["What AI Does (Wrong)", "What to Write Instead", "When `var` Is Acceptable"], "rules": ["Always declare type on QML properties — never use `var` for known types", "Use `var` ONLY when the type is genuinely dynamic", "Property types are the ONLY type-safety QML gives you — use them"], "banned": [], "anti_patterns": ["property var userName: \"\""], "correct_patterns": ["property string userName: \"\""], "refs": ["performance.md", "glue-code.md", "validation.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["discipline", "qml", "type", "type-conversion", "type-safety"], "qt_apis": [], "concepts": ["type-conversion", "type-safety"]}
{"file": "js/validation.md", "category": "js", "type": "content", "title": "Validation at Boundaries", "subtitle": "QML JS has no Zod, no schema validation. The C++ layer does this.", "sections": ["Pattern"], "rules": ["Validate data from C++ -> QML at the C++ side BEFORE exposing to QML", "QML JS has no Zod, no schema validation — the C++ layer does this", "JSON from external sources: parse and validate in C++, expose typed QVariant to QML"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["network.md", "glue-code.md", "types.md"], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["boundaries", "cpp", "qbytearray", "qjsondocument", "qjsonparseerror", "qml", "qvariant", "qvariantmap", "schema", "type-checking", "validation"], "qt_apis": ["QByteArray", "QJsonDocument", "QJsonParseError", "QVariant", "QVariantMap"], "concepts": ["schema", "type-checking"]}
{"file": "qml/README.md", "category": "qml", "type": "readme", "title": "QML Rules — Anti-Patterns AI Gets Wrong", "subtitle": "QML is declarative. AI writes it imperatively. This mismatch causes broken bindings, layout bugs, and unmaintainable code.", "sections": ["The Problem", "File Index"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["bindings.md", "file-size.md", "layout.md", "states.md", "loader.md", "models.md", "signals.md", "scope.md", "required-properties.md", "quick-ref.md", "file-organization.md"], "code_languages": [], "has_examples": false, "tags": ["anti-patterns", "gets", "qml", "rules", "wrong"], "qt_apis": [], "concepts": []}
{"file": "qml/bindings.md", "category": "qml", "type": "content", "title": "Bindings Are Sacred — Never Assign Imperatively", "subtitle": "QML properties bind to expressions — they re-evaluate automatically. Imperative assignment breaks this contract permanently.", "sections": ["What AI Does (Wrong)", "What to Write Instead", "When You Must Assign Dynamically"], "rules": ["QML properties bind to expressions — they re-evaluate automatically", "Imperative assignment (`property = value`) BREAKS the binding permanently", "If you must reset a value, re-establish the binding with `Qt.binding()`"], "banned": ["Imperative property assignment to a bound property", "Using `onXChanged` handlers to propagate values that should be bindings"], "anti_patterns": ["Rectangle {"], "correct_patterns": ["Rectangle {"], "refs": ["states.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["assign", "bindings", "declarative", "imperatively", "never", "qml", "reactive", "sacred"], "qt_apis": [], "concepts": ["declarative", "reactive"]}
{"file": "qml/file-organization.md", "category": "qml", "type": "content", "title": "File Organization", "subtitle": "Each .qml file = one visual component. Group by role. Keep it flat.", "sections": [], "rules": ["Each .qml file = one visual component", "delegates/ for ListView/TreeView delegates", "singletons/ for shared state (Theme, App config)", "Never put .js helper files alongside .qml — put shared JS in a lib/ folder with `.pragma library`"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["file-size.md", "loader.md", "required-properties.md", "quick-ref.md"], "code_languages": [], "has_examples": false, "tags": ["code-organization", "file", "organization", "structure"], "qt_apis": [], "concepts": ["code-organization", "structure"]}
{"file": "qml/file-size.md", "category": "qml", "type": "content", "title": "Keep QML Files Small and Focused", "subtitle": "One visual concept per file. Max 150 lines. Extract early.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Max 150 lines per QML file", "One visual concept per file", "Extract components when a subtree exceeds 50 lines", "Inline `Component {}` only for delegates under 20 lines"], "banned": [], "anti_patterns": ["ApplicationWindow {"], "correct_patterns": ["ApplicationWindow {"], "refs": ["file-organization.md", "loader.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["code-organization", "files", "focused", "keep", "maintainability", "qml", "small"], "qt_apis": [], "concepts": ["code-organization", "maintainability"]}
{"file": "qml/layout.md", "category": "qml", "type": "content", "title": "Anchors and Layouts — Never Absolute Position", "subtitle": "Use anchors for parent-relative positioning. Use Layouts for arranged children. Never use x:/y: for static layout.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use `anchors` for parent-relative positioning", "Use `RowLayout`/`ColumnLayout`/`GridLayout` for arranged children", "Never use `x:`/`y:` for static layout (only for animation/drag)", "Never mix anchors and Layouts on the same item"], "banned": ["`x:` / `y:` for layout (only for drag, animation, or Canvas)", "Manual `width: parent.width - 40` calculations", "Mixing `anchors` with `Layout.*` on the same item"], "anti_patterns": ["Rectangle {"], "correct_patterns": ["Rectangle {", "ColumnLayout {"], "refs": ["bindings.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["absolute", "anchors", "layouts", "never", "position", "positioning", "qml", "responsive"], "qt_apis": [], "concepts": ["positioning", "responsive"]}
{"file": "qml/loader.md", "category": "qml", "type": "content", "title": "Loader for On-Demand Creation", "subtitle": "Use Loader for heavy components that may not be needed. Setting visible: false still creates the component and keeps it in memory.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use `Loader` for heavy components that may not be needed", "Use `Loader` for conditional content (not `visible: false`)", "Setting `visible: false` still creates and keeps the component in memory"], "banned": [], "anti_patterns": ["SettingsPanel { visible: settingsOpen }"], "correct_patterns": ["Loader {"], "refs": ["file-size.md", "states.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["creation", "lazy-loading", "loader", "on-demand", "performance", "qml"], "qt_apis": [], "concepts": ["lazy-loading", "performance"]}
{"file": "qml/models.md", "category": "qml", "type": "content", "title": "Models — Use C++ Models, Not JS Arrays", "subtitle": "ListModel for static/small lists. QAbstractListModel for everything else. Never build models in JS — marshalling cost kills performance.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["ListModel for static/small lists only (< 20 items)", "QAbstractListModel (C++) for dynamic, large, or filtered lists", "Never build models in JS — marshalling cost kills performance", "Never use `model: myJsArray.length` with manual indexing"], "banned": [], "anti_patterns": ["property var files: []"], "correct_patterns": ["class FileListModel : public QAbstractListModel {", "ListView {"], "refs": ["required-properties.md", "signals.md", "quick-ref.md"], "code_languages": ["cpp", "qml"], "has_examples": true, "tags": ["arrays", "cpp", "models", "q_object", "qabstractlistmodel", "qml", "use"], "qt_apis": ["QAbstractListModel", "Q_OBJECT"], "concepts": []}
{"file": "qml/quick-ref.md", "category": "qml", "type": "quick-ref", "title": "Common AI Mistakes — Quick Reference", "subtitle": "One table of everything AI gets wrong in QML, with the correct pattern.", "sections": [], "rules": [], "banned": [], "anti_patterns": ["property = value in handler", "400-line QML files", "x: / y: for layout", "JS if/else for visual state", "visible: false for heavy items", "JS arrays as model", "JS callbacks between components", "id reference across files", "model.roleName in Qt 6", "Timer { repeat: true } for polling", "Inline Component (100+ lines)", "Math.round(parent.width * 0.3)", "onCompleted: { ... 30 lines }", "children[0], parent.parent"], "correct_patterns": ["Let binding auto-update, or Qt.binding()", "Max 150 lines, extract components", "anchors or Layout", "states + PropertyChanges", "Loader { active: condition }", "QAbstractListModel from C++", "QML signals", "Pass via required property", "required property type name", "C++ signal on data change", "Separate .qml file", "Layout.preferredWidth or anchors", "Move to C++ init method", "Named properties, proper API"], "refs": ["bindings.md", "file-size.md", "layout.md", "states.md", "loader.md", "models.md", "signals.md", "scope.md", "required-properties.md"], "code_languages": [], "has_examples": false, "tags": ["common", "mistakes", "qabstractlistmodel", "quick", "reference"], "qt_apis": ["QAbstractListModel"], "concepts": []}
{"file": "qml/required-properties.md", "category": "qml", "type": "content", "title": "Required Properties (Qt 6)", "subtitle": "Use required property for delegate properties in Qt 6. This replaces the old model.roleName attached property pattern.", "sections": ["What AI Does (Wrong — Mixes Qt 5 and 6 Patterns)", "What to Write Instead"], "rules": ["Use `required property` for delegate properties in Qt 6", "This replaces the old `model.roleName` attached property pattern", "Required properties are type-checked and produce clear error messages"], "banned": [], "anti_patterns": ["delegate: Item {"], "correct_patterns": ["delegate: Item {"], "refs": ["scope.md", "models.md", "signals.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["encapsulation", "properties", "qml", "required", "type-safety"], "qt_apis": [], "concepts": ["encapsulation", "type-safety"]}
{"file": "qml/scope.md", "category": "qml", "type": "content", "title": "id References — Scope Matters", "subtitle": "id is scoped to the QML file where it is declared. Never rely on id from a parent file inside a component.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["`id` is scoped to the QML file where it is declared", "Never rely on `id` from a parent file inside a component", "Pass data via properties, not via id references across files"], "banned": [], "anti_patterns": ["Item {"], "correct_patterns": ["FileDelegate {"], "refs": ["required-properties.md", "signals.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["encapsulation", "isolation", "matters", "qml", "references", "scope"], "qt_apis": [], "concepts": ["encapsulation", "isolation"]}
{"file": "qml/signals.md", "category": "qml", "type": "content", "title": "Signals and Connections — Not Callbacks", "subtitle": "QML uses signals for component communication, not JS callbacks. Parent communicates down via properties. Child communicates up via signals.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["QML uses signals — not JS callbacks — for component communication", "Parent communicates down via properties", "Child communicates up via signals", "Sibling communication goes through parent or shared model"], "banned": [], "anti_patterns": ["FileList {"], "correct_patterns": ["Item {"], "refs": ["scope.md", "required-properties.md", "models.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["callbacks", "connections", "event-handling", "qml", "signals", "signals-slots"], "qt_apis": [], "concepts": ["event-handling", "signals-slots"]}
{"file": "qml/states.md", "category": "qml", "type": "content", "title": "Use States, Not If/Else JS", "subtitle": "QML states + PropertyChanges for multi-property visual switches. Transitions for animated state changes. Never toggle properties imperatively.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["QML `states` + `PropertyChanges` for multi-property visual switches", "Transitions for animated state changes", "Never use JS if/else to toggle multiple properties imperatively"], "banned": [], "anti_patterns": ["function setEditMode(editing) {"], "correct_patterns": ["states: ["], "refs": ["bindings.md", "loader.md", "quick-ref.md"], "code_languages": ["qml"], "has_examples": true, "tags": ["else", "qml", "state-management", "states", "use", "visual-states"], "qt_apis": [], "concepts": ["state-management", "visual-states"]}
{"file": "rust/README.md", "category": "rust", "type": "readme", "title": "Rust in Qt — Rules and AI Anti-Patterns", "subtitle": "Rust's ownership model and Qt's ownership model are fundamentally different. AI will try to apply Rust idioms that directly conflict with how Qt objects work.", "sections": ["The Problem", "File Index"], "rules": [], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["cxx-qt.md", "pin.md", "ownership.md", "signals.md", "async.md", "errors.md", "q-property.md", "types.md", "core-isolation.md", "quick-ref.md"], "code_languages": [], "has_examples": false, "tags": ["anti-patterns", "q_property", "qobject", "rules", "rust"], "qt_apis": ["QObject", "Q_PROPERTY"], "concepts": []}
{"file": "rust/async.md", "category": "rust", "type": "content", "title": "Async: Qt Event Loop, Not Tokio", "subtitle": "Qt has its own event loop. Do not run Tokio or async-std alongside it. Use threads and channels instead.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Do NOT use tokio or async-std runtime alongside Qt's event loop", "Qt has its own event loop (QCoreApplication::exec) — it must be primary", "For async work, use QThread + channels or spawn_blocking from Qt thread", "Bridge async Rust to Qt via channels, not runtime integration"], "banned": ["`#[tokio::main]` in Qt applications", "`.await` inside cxx-qt method implementations", "Running two event loops (tokio + Qt)"], "anti_patterns": ["async fn main() {", "impl qobject::Backend {"], "correct_patterns": ["impl qobject::Backend {", "impl qobject::Backend {"], "refs": ["signals.md", "errors.md", "pin.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["async", "concurrency", "event", "event-loop", "loop", "qapplication", "qcoreapplication", "qstring", "qthread", "qtimer", "rust", "tokio"], "qt_apis": ["QApplication", "QCoreApplication", "QString", "QThread", "QTimer"], "concepts": ["concurrency", "event-loop"]}
{"file": "rust/core-isolation.md", "category": "rust", "type": "content", "title": "Core Logic Isolation", "subtitle": "Core Rust code has NO Qt dependency. The cxx-qt bridge is a thin adapter between core and Qt.", "sections": ["Project Structure", "Dependency Direction"], "rules": ["Core Rust code has NO Qt dependency — pure Rust crate", "cxx-qt bridge is an ADAPTER — thin layer between core and Qt", "Core crate compiles and tests without Qt installed", "Same hexagonal pattern as C++ Qt apps (see hexagon.md)"], "banned": ["`use cxx_qt_lib::*` in core crate", "Qt types in core function signatures", "Core tests that require QApplication"], "anti_patterns": [], "correct_patterns": [], "refs": ["types.md", "errors.md", "cxx-qt.md"], "code_languages": [], "has_examples": false, "tags": ["#[cxx_qt::bridge]", "architecture", "core", "isolation", "logic", "qabstractlistmodel", "qapplication", "qguiapplication", "separation"], "qt_apis": ["#[cxx_qt::bridge]", "QAbstractListModel", "QApplication", "QGuiApplication"], "concepts": ["architecture", "separation"]}
{"file": "rust/cxx-qt.md", "category": "rust", "type": "content", "title": "cxx-qt Is the Bridge — Not Raw FFI", "subtitle": "Use cxx-qt for all Qt/Rust integration. Never write manual FFI for QObject methods.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use cxx-qt for Qt/Rust integration — not raw cxx or bindgen", "cxx-qt handles moc generation, Pin safety, and signal/slot wiring", "Never write manual extern \"C\" bindings for QObject methods", "All QML-exposed types go through #[cxx_qt::bridge]"], "banned": [], "anti_patterns": ["extern \"C\" {"], "correct_patterns": ["mod ffi {"], "refs": ["pin.md", "signals.md", "q-property.md", "quick-ref.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[cxx_qt::bridge]", "#[qml_element]", "#[qobject]", "bridge", "cxx-qt", "ffi", "interop", "ipc", "qobject", "qstring", "qwidget", "raw", "rust"], "qt_apis": ["#[cxx_qt::bridge]", "#[qml_element]", "#[qobject]", "QObject", "QString", "QWidget"], "concepts": ["bridge", "ffi", "interop", "ipc"]}
{"file": "rust/errors.md", "category": "rust", "type": "content", "title": "Error Handling: Result → Qt Signals", "subtitle": "Rust Result types must be mapped to Qt signals at the bridge boundary. Never let a panic cross FFI.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Rust `Result<T, E>` must be mapped to Qt signals at the boundary", "`?` operator works inside Rust functions — but bridge methods must handle errors", "Never let a panic cross the FFI boundary — it's undefined behavior", "Use `catch_unwind` at bridge boundaries if panic is possible"], "banned": ["Returning `Result` from #[qinvokable] methods", "`unwrap()`/`expect()` in bridge code (panic crosses FFI → UB)", "`panic!()` in any cxx-qt method"], "anti_patterns": ["fn load_file(self: Pin<&mut Self>, path: &QString) -> Result<(), ConfigError> {"], "correct_patterns": ["impl qobject::Backend {"], "refs": ["signals.md", "async.md", "core-isolation.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[qinvokable]", "error", "error-handling", "event-handling", "handling", "qstring", "result", "rust", "signals", "signals-slots"], "qt_apis": ["#[qinvokable]", "QString"], "concepts": ["error-handling", "event-handling", "signals-slots"]}
{"file": "rust/ownership.md", "category": "rust", "type": "content", "title": "Ownership: Qt Parent-Child vs Rust Ownership", "subtitle": "Rust's single-owner model and Qt's parent-child tree are fundamentally different. Mixing them causes double frees or dangling pointers.", "sections": ["The Conflict", "What AI Does (Wrong)", "What to Write Instead"], "rules": ["QObject parent-child ownership is managed by Qt, not Rust", "Rust code does NOT own QObject instances created for QML", "Use references and lifetimes — never Box<QObject> or Rc<QObject>", "Let cxx-qt handle the ownership bridge"], "banned": [], "anti_patterns": ["let widget = Box::new(MyWidget::new());  // Rust owns it"], "correct_patterns": ["mod ffi {"], "refs": ["pin.md", "cxx-qt.md", "errors.md", "quick-ref.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[cxx_qt::bridge]", "#[qinvokable]", "#[qml_element]", "#[qobject]", "lifetime", "memory-management", "ownership", "parent-child", "qobject", "qstring", "rust"], "qt_apis": ["#[cxx_qt::bridge]", "#[qinvokable]", "#[qml_element]", "#[qobject]", "QObject", "QString"], "concepts": ["lifetime", "memory-management"]}
{"file": "rust/pin.md", "category": "rust", "type": "content", "title": "Pin — Qt Objects Cannot Move", "subtitle": "Qt stores internal pointers that break on move. All QObject types in Rust must be Pin.", "sections": ["What AI Does (Wrong)", "What to Write Instead", "Why Pin Matters"], "rules": ["All QObject types in Rust must be `Pin<&mut T>`", "cxx-qt generates Pin-based APIs — follow them, don't fight them", "Never try to move, clone, or mem::swap a Qt object", "Pin is NOT optional — Qt stores internal pointers that break on move"], "banned": [], "anti_patterns": ["let mut backend = Backend::new();"], "correct_patterns": ["impl qobject::Backend {"], "refs": ["ownership.md", "cxx-qt.md", "quick-ref.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["cannot", "memory-safety", "move", "move-semantics", "objects", "pin", "qobject", "qstring", "rust"], "qt_apis": ["QObject", "QString"], "concepts": ["memory-safety", "move-semantics"]}
{"file": "rust/q-property.md", "category": "rust", "type": "content", "title": "Q_PROPERTY from Rust", "subtitle": "Use #[qproperty(Type, name)] on the qobject struct. cxx-qt generates getter, setter, and NOTIFY signal automatically.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Use `#[qproperty(Type, name)]` attribute on the qobject struct", "cxx-qt generates getter, setter, and NOTIFY signal automatically", "The Rust struct field holds the value — cxx-qt bridges it to Qt"], "banned": [], "anti_patterns": ["impl Backend {"], "correct_patterns": ["mod ffi {"], "refs": ["types.md", "signals.md", "cxx-qt.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[cxx_qt::bridge]", "#[qml_element]", "#[qobject]", "data-binding", "property", "q-property", "q_property", "qstring", "rust"], "qt_apis": ["#[cxx_qt::bridge]", "#[qml_element]", "#[qobject]", "QString", "Q_PROPERTY"], "concepts": ["data-binding", "q-property"]}
{"file": "rust/quick-ref.md", "category": "rust", "type": "quick-ref", "title": "Common AI Mistakes — Quick Reference", "subtitle": "One-table summary of what AI gets wrong and the correct cxx-qt pattern.", "sections": ["Detailed Rules by Topic"], "rules": [], "banned": [], "anti_patterns": ["Raw FFI (extern \"C\")", "Moving QObject", "Box<QObject>", "Manual signal emit", "#[tokio::main]", ".await in bridge method", "Result return from #[qinvokable]", "Manual getter/setter", "String in Qt API", "unwrap() in bridge", "Qt types in core crate", "Rc<RefCell<>> for Qt object", "Send + Sync on QObject"], "correct_patterns": ["#[cxx_qt::bridge]", "Everything is Pin<&mut T>", "Let Qt own via parent, Rust refs via cxx-qt", "#[qsignal] attribute + generated method", "std::thread + qt_thread.queue()", "Spawn thread, queue result back", "Map to signal: ok → data signal, err → error signal", "#[qproperty(Type, name)]", "QString via cxx-qt-lib", "Always handle with match", "Pure Rust core, convert at bridge", "Qt parent-child + Pin", "Use qt_thread.queue() for cross-thread"], "refs": ["cxx-qt.md", "pin.md", "ownership.md", "signals.md", "async.md", "errors.md", "q-property.md", "types.md", "core-isolation.md"], "code_languages": [], "has_examples": false, "tags": ["#[cxx_qt::bridge]", "#[qinvokable]", "#[qsignal]", "common", "mistakes", "qobject", "qstring", "quick", "reference"], "qt_apis": ["#[cxx_qt::bridge]", "#[qinvokable]", "#[qsignal]", "QObject", "QString"], "concepts": []}
{"file": "rust/signals.md", "category": "rust", "type": "content", "title": "Signals from Rust — Use cxx-qt Macros", "subtitle": "Declare signals via #[qsignal] in the cxx-qt bridge. Never invent manual signal emission APIs.", "sections": ["What AI Does (Wrong)", "What to Write Instead"], "rules": ["Declare signals via #[qsignal] attribute in cxx-qt bridge", "Emit signals through the generated API — not manual C++ calls", "Signal emission must happen on the Qt thread that owns the object"], "banned": [], "anti_patterns": ["impl Backend {"], "correct_patterns": ["mod ffi {"], "refs": ["errors.md", "async.md", "cxx-qt.md", "q-property.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[cxx_qt::bridge]", "#[qobject]", "#[qsignal]", "bridge", "cxx-qt", "event-handling", "ffi", "macros", "qstring", "rust", "signals", "signals-slots", "use"], "qt_apis": ["#[cxx_qt::bridge]", "#[qobject]", "#[qsignal]", "QString"], "concepts": ["bridge", "event-handling", "ffi", "signals-slots"]}
{"file": "rust/types.md", "category": "rust", "type": "content", "title": "Type Mapping: Rust ↔ Qt", "subtitle": "Use cxx-qt-lib types at the Qt/Rust boundary. Convert to standard Rust types in core logic.", "sections": ["Conversion Pattern"], "rules": ["Use cxx-qt-lib types for Qt/Rust boundary", "Convert to standard Rust types in core logic", "Never pass `String` directly to Qt — use `QString`"], "banned": [], "anti_patterns": [], "correct_patterns": [], "refs": ["core-isolation.md", "q-property.md", "errors.md"], "code_languages": ["rust"], "has_examples": true, "tags": ["#[qinvokable]", "mapping", "qhash", "qlist", "qmap", "qstring", "qurl", "qvariantmap", "qvector", "rust", "type", "type-conversion", "type-safety"], "qt_apis": ["#[qinvokable]", "QHash", "QList", "QMap", "QString", "QUrl", "QVariantMap", "QVector"], "concepts": ["type-conversion", "type-safety"]}
